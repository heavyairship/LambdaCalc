#!/usr/bin/python3

import sys
from optparse import OptionParser
from lambdacalc.LambdaCalc import *

def testReductions():
    print("Running reduction unit tests...")

    # Simple formulas
    assert str(Var("x").red()) == "x"
    assert str(Abs("x", Var("M")).red()) == "(Lx.M)"
    assert str(App(Var("M"), Var("N")).red()) == "(M N)"

    # Applications of variables
    assert str(App(Var("x"), Var("y")).red()) == "(x y)"
    assert str(App(Var("x"), Abs("x", Var("M"))).red()) == "(x (Lx.M))"
    assert str(App(Var("x"), App(Var("M"), Var("N"))).red()) == "(x (M N))"

    # Applications of basic abstractions
    assert str(App(Abs("x", Var("x")), Var("x")).red()) == "x"
    assert str(App(Abs("x", Var("x")), Abs("x", Var("x"))).red()) == "(Lx.x)"
    assert str(App(Abs("x", Var("x")), App(Var("M"), Var("N"))).red()) == "(M N)"

    # Application of abstraction with capture-avoiding substitution
    assert str(App(Abs("x", Var("M")), Var("x")).red()) == "M"
    assert str(App(Abs("x", Var("M")), Var("z")).red()) == "M"
    assert str(App(Abs("x", Var("x")), Var("r")).red()) == "r"
    assert str(App(Abs("x", Var("y")), Var("r")).red()) == "y"
    assert str(App(Abs("x", App(Var("t"), Var("s"))), Var("r")).red()) == "(t s)"
    assert str(App(Abs("x", App(Var("x"), Var("x"))), Var("r")).red()) == "(r r)"
    assert str(App(Abs("x", Abs("x", Var("t"))), Var("r")).red()) == "(Lx.t)"
    body = Abs("x", App(Var("x"), Var("y")))
    abst = Abs("y", body)
    assert str(App(abst, Var("x")).red()) == "(L@0.(@0 x))" # renaming example (alpha-conversion)
    resetFresh()

    # Application of applications
    assert str(App(App(Var("M"), Var("N")), Var("x")).red()) == "((M N) x)"
    assert str(App(App(Var("M"), Var("N")), Abs("x", Var("x"))).red()) == "((M N) (Lx.x))"
    assert str(App(App(Var("M"), Var("N")), App(Var("A"), Var("B"))).red()) =="((M N) (A B))"

    print("Unit tests for reductions passed!")

def testChurchEncoding():
    print("Running Church encoding unit tests...")

    # Test encoding
    zero = "(Lf.(Lx.x))"
    one = "(Lf.(Lx.(f x)))"
    two = "(Lf.(Lx.(f (f x))))"
    three = "(Lf.(Lx.(f (f (f x)))))"
    assert str(encodeI(0)) == zero
    assert str(encodeI(1)) == one
    assert str(encodeI(2)) == two
    assert str(encodeI(3)) == three

    # Test decoding
    assert decodeI(parse(zero)) == 0
    assert decodeI(parse(one)) == 1
    assert decodeI(parse(two)) == 2
    assert decodeI(parse(three)) == 3

    # Test inverse property for encodeI/decodeI
    assert decodeI(encodeI(0)) == 0
    assert decodeI(encodeI(1)) == 1
    assert decodeI(encodeI(2)) == 2
    assert decodeI(encodeI(3)) == 3
    assert str(encodeI(decodeI(parse(zero)))) == zero
    assert str(encodeI(decodeI(parse(one)))) == one
    assert str(encodeI(decodeI(parse(two)))) == two
    assert str(encodeI(decodeI(parse(three)))) == three
    print("Unit tests for Church encodings passed!")

def testInfiniteLoop():
    print("Running infinite loop tests...")
    infloop = parse("((Lx.(x x)) (Lx.(x x)))")
    for i in range(10):
        assert str(infloop) == str(infloop.red())
        infloop = infloop.red()
    try:
        infloop.bigRed()
        assert False
    except RecursionError:
        pass
    print("Infinite loop tests passed!")

parser = OptionParser()
parser.add_option("-f", "--file", dest="filename", help="path to lambda calc file", type=str)
(options, args) = parser.parse_args()
if options.filename:
    print()
    print("Running test file `%s`..." % options.filename)
    with open(options.filename) as f:
        rawInput = f.read()
        print("Raw input: %s" % rawInput[0:-1])
        parsedExpr = parse(rawInput)
        if parsedExpr is not None:
            print("Parsed expression: %s" % parsedExpr)
            redExpr = parsedExpr.bigRed()
            print("Reduced expression: %s" % redExpr)
        else:
            print("Parsed empty expression")
    print("Done")
else:
    print()
    print("Running unit tests...")
    testReductions()
    testChurchEncoding()
    testInfiniteLoop()
    print("Done")

